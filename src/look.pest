newline    = _{ "\n" }
whitespace = _{ " " | newline }
comment = _{ "//" ~ (!newline ~ any)* }

digit = { '0'..'9' }
bin_digit = { "0" | "1" }
hex_digit = { digit | 'A'..'F' }
alpha = { 'a'..'z' | 'A'..'Z' }
alphanum = { alpha | digit }
sid_char = { alphanum | "_" }

// Keywords
_use = { "use" }
_mod = { "mod" }
_self = { "self" }
_super = { "super" }
_dep = { "dep" }
_magic = { "magic" }
_goto = { "goto" }
_label = { "label" }
_break = { "break" }
_return = { "return" }
_loop = { "loop" }
_case = { "case" }
_if = { "if" }
_else = { "else" }
_val = { "val" }
_as = { "as" }
_type_kw = { "type" }
_macro = { "macro" }
_mut = { "mut" }
_pub = { "pub" }
_ffi = { "ffi" }
keyword = { _use | _mod | _self | _super | _dep | _magic | _goto | _label | _break | _return | _loop | _case | _if | _else | _val | _as | _type_kw | _macro | _mut | _pub | _ffi }

// Punctuation
scope = { "::" }

// Identifiers
sid = @{ !keyword ~ ((alpha ~ (sid_char{0, 126})) | ("_" ~ (sid_char{1, 126}))) ~ !sid_char }
id = { sid ~ (scope ~ sid)* }

// Literals
dec_int = @{ digit ~ (digit | "_")* }
bin_int = @{ "0b" ~ "_"* ~ bin_digit ~ (bin_digit | "_")* }
hex_int = @{ "0x" ~ "_"* ~ hex_digit ~ (hex_digit | "_")* }
float = @{ dec_int ~ "." ~ "_"* ~ dec_int ~ ("e" ~ ("+" | "-")? ~ "_"* ~ dec_int )? }
string = @{ "\"" ~ string_inner* ~ "\"" }
string_inner = @{ (!("\"" | "\\") ~ any) | escape }
escape = @{ "\\" ~ ("\\" | "\"" | "n" | "t" | "0" | ("u" ~ hex_digit{4})) }
literal = { bin_int | hex_int | float | dec_int | string }

// Attributes
meta_item_nullary =  { sid }
meta_item_pair = { sid ~ "=" ~ literal }
meta_item_lit_arg = { sid ~ "(" ~ literal ~ ")" }
meta_item_args = { sid ~ "(" ~ meta_item ~ ("," ~ meta_item)* ~ ")" }
meta_item = { meta_item_pair | meta_item_lit_arg | meta_item_args | meta_item_nullary }
attribute = { "#[" ~ meta_item ~ "]" }

// Macros
macro_invocation = ${ "$" ~ id ~ "(" ~ macro_args ~ ")" }
non_paren = @{ (!("(" | ")") ~ any) }
macro_args = @{ (non_paren | ("(" ~ macro_args ~ ")"))* }

repetition = { bin_int | hex_int | dec_int | macro_invocation }

// Types
fun_named_type = { product_named_type ~ "->" ~ _type }
fun_anon_type = { product_anon_type ~ "->" ~ _type }
actual_named_product_field_type = { sid ~ ":" ~ _type }
named_product_field_type = { (attribute+ ~ "{" ~ actual_named_product_field_type ~ "}") | actual_named_product_field_type }
product_named_type = { "(" ~ named_product_field_type ~ ("," ~ named_product_field_type)* ~ ")" }
product_anon_type = { "(" ~ ( _type ~ ("," ~ _type)* | "") ~ ")" }
product_repeated_type = { "(" ~ _type ~ ";" ~ repetition ~ ")" }
array_type = { "[" ~ _type ~ "]" }
ptr_mut_type = { "~" ~ _type }
ptr_type = { "@" ~ _type }
actual_named_type_arg = { sid ~ "=" ~ _type }
named_type_arg = { (attribute+ ~ "{" ~ actual_named_type_arg ~ "}") | actual_named_type_arg }
type_application_named = { id ~ "<" ~ named_type_arg ~ ("," ~ named_type_arg)* ~ ">" }
type_application_anon = { id ~ "<" ~ _type ~ ("," ~ _type)* ~ ">" }
actual_type = { type_application_named | type_application_anon | id | macro_invocation | ptr_type | ptr_mut_type | array_type | product_repeated_type | fun_named_type | fun_anon_type | product_named_type | product_anon_type }
_type = { (attribute+ ~ "{" ~ actual_type ~ "}") | actual_type }

// TypeDefs
type_level_arg = { (attribute+ ~ "{" ~ sid ~ "}") | sid }
actual_type_level_fun = { "<" ~ type_level_arg ~ ("," ~ type_level_arg)* ~ ">" ~ "=>" ~ type_def }
type_level_fun = { (attribute+ ~ "{" ~ actual_type_level_fun ~ "}") | actual_type_level_fun }
actual_summand = { "|" ~ sid ~ (product_named_type | product_anon_type | "") }
summand = { ((attribute+ ~ "{" ~ actual_summand ~ "}") | actual_summand ) }
sum = { ((attribute+ ~ "{" ~ _pub? ~ summand+ ~ "}") | (_pub? ~ summand+)) }
type_def = { sum | type_level_fun | _type }

// Patterns
summand_pattern = { "|" ~ sid ~ (product_named_pattern | product_anon_pattern | "") }
maybe_annotated_named_pattern = { (attribute+ ~ "{" ~ sid ~ "=" ~ pattern ~ "}") | (sid ~ "=" ~ pattern) }
product_named_pattern = { "(" ~ maybe_annotated_named_pattern ~ ("," ~ maybe_annotated_named_pattern)* ~ ")" }
maybe_annotated_pattern = { (attribute+ ~ "{" ~ pattern ~ "}") | pattern }
product_anon_pattern = { ("(" ~ ")") | ("(" ~ maybe_annotated_pattern ~ ("," ~ maybe_annotated_pattern)* ~ ")") }
id_pattern = { _mut? ~ sid ~ (":" ~ _type)? }
ptr_pattern = { "@" ~ pattern }
blank_pattern = { "_" }
pattern = { id_pattern | blank_pattern | literal | ptr_pattern | product_named_pattern | product_anon_pattern | summand_pattern }

// Not an expression, but used as part of many expressions
block = { "{" ~ ((expression ~ (";" ~ expression)*) | "") ~ "}" }

// Left recursive expressions
assignment_ = { "=" ~ expression }
cast_ = { "as" ~ _type }
product_access_anon_ = { "." ~ literal }
product_access_named_ = { "." ~ sid }
array_index_ = { "[" ~ expression ~ "]" }
deref_mut_ = { "~" }
deref_ = { "@" }
expression_ = { deref_ | deref_mut_ | array_index_ | product_access_named_ | product_access_anon_ | cast_ | product_named_expression | product_anon_expression | assignment_ | "" }

// Expressions
break_expression = { _break ~ expression? }
return_expression = { _return ~ expression? }
loop_expression = { _loop ~ expression ~ "{" ~ (pattern ~ block)* ~ "}" }
case_expression = { _case ~ expression ~ "{" ~ (pattern ~ block)* ~ "}" }
// if_expression = { _if ~ expression ~ block ~ (_else ~ (if_expression | block))? }
val_expression = { _val ~ pattern ~ ("=" ~ expression)? }
generic_expression = { "<" ~ type_level_arg ~ ("," ~ type_level_arg)* ~ ">" ~ "=>" ~ expression }
fun_literal = { product_anon_pattern ~ "->" ~ _type ~ block }
actual_named_product_field_expression = { sid ~ "=" ~ expression }
named_product_field_expression = { (attribute+ ~ "{" ~ actual_named_product_field_expression ~ "}") | actual_named_product_field_expression }
product_named_expression = { "(" ~ named_product_field_expression ~ ("," ~ named_product_field_expression)* ~ ")" }
product_anon_expression = { "(" ~ ( expression ~ ("," ~ expression)* | "") ~ ")" }
product_repeated_expression = { "(" ~ expression ~ ";" ~ repetition ~ ")" }
array_expression = { "[" ~ expression ~ "]" }
ref_expression = { "@" ~ expression }
ref_mut_expression = { "~" ~ expression }
lexpression = { literal | type_application_named | type_application_anon | id | macro_invocation | ref_expression | ref_mut_expression | array_expression | product_repeated_expression | fun_literal | product_named_expression | product_anon_expression | generic_expression | val_expression | case_expression | loop_expression | return_expression | break_expression } // | if_expression
expression = { (attribute+ ~ "{" ~ lexpression ~ expression_ ~ "}") | (lexpression ~ expression_) }

// Uses
use_prefix = { (_mod ~ scope) | (_dep ~ scope) | (_magic ~ scope) | "" }
attributed_use_tree = { attribute+ ~ "{" ~ use_tree ~ "}" }
use_branch = { use_tree | ("{" ~ (use_tree | attributed_use_tree) ~ ("," ~ (use_tree | attributed_use_tree))* ~ "}") }
use_tree = {(_self ~ (_as ~ sid)?) | (sid ~ scope ~ use_branch) | (sid ~ (_as ~ sid)?) | (_super ~ scope ~ use_branch) }

// Items
ffi_type = { _pub? ~ _type_kw ~ sid }
ffi_val = { _pub? ~ _val ~ sid ~ ":" ~ _type }
ffi_item = { ffi_type | ffi_val }
ffi_language = { "C" }
ffi_block = { _ffi ~ ffi_language ~ "{" ~ (ffi_item | (attribute+ ~ "{" ~ ffi_item ~ "}"))* ~ "}" }
val_item = { _pub? ~ _val ~ pattern ~ "=" ~ expression }
type_item = { _pub? ~ _type_kw ~ sid ~ "=" ~ type_def }
use_item = { _pub? ~ _use ~ use_prefix ~ use_tree  }
item = { use_item | type_item | val_item | ffi_block }

// A file of look code
file_item = { item | (attribute+ ~ "{" ~ item ~ "}") }
file = { file_item* }
